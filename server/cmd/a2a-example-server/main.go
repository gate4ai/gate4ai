package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/gate4ai/gate4ai/server/a2a"
	"github.com/gate4ai/gate4ai/server/mcp"
	"github.com/gate4ai/gate4ai/server/transport"
	"github.com/gate4ai/gate4ai/shared"
	a2aSchema "github.com/gate4ai/gate4ai/shared/a2a/2025-draft/schema"
	"github.com/gate4ai/gate4ai/shared/config"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var coderAgentCard = a2aSchema.AgentCard{
	Name:        "Go Coder Agent (A2A)",
	Description: shared.PointerTo("An agent that generates code based on natural language instructions and streams file outputs."),
	URL:         "", // Will be set based on listen address
	Provider: &a2aSchema.AgentProvider{
		Organization: "Gate4AI MCP Examples",
	},
	Version: "0.1.0",
	Capabilities: a2aSchema.AgentCapabilities{
		Streaming:              true, // We implement tasks/sendSubscribe
		PushNotifications:      false,
		StateTransitionHistory: false, // Not implemented in this example
	},
	Authentication:     nil, // No auth for this example
	DefaultInputModes:  []string{"text"},
	DefaultOutputModes: []string{"text", "file"}, // Outputs code as text/file artifacts
	Skills: []a2aSchema.AgentSkill{
		{
			ID:          "code_generation",
			Name:        "Code Generation",
			Description: shared.PointerTo("Generates code snippets or complete files based on user requests, streaming the results."),
			Tags:        []string{"code", "development", "programming", "go"},
			Examples: []string{
				"Write a Go function to calculate fibonacci numbers.",
				"Create an HTML file with a basic button that alerts 'Hello!' when clicked.",
				"Generate a Go struct for a user profile with name and email properties.",
				"Write unit tests for the following Go function.",
			},
		},
	},
}

// coderAgentHandler implements the A2AHandler interface for the Coder Agent logic.
func coderAgentHandler(ctx context.Context, task *a2aSchema.Task, updates chan<- a2a.A2AYieldUpdate) error {
	// 1. Send initial "working" status
	workingStatus := a2aSchema.TaskStatus{
		State: a2aSchema.TaskStateWorking,
		Message: &a2aSchema.Message{
			Role:  "agent",
			Parts: []a2aSchema.Part{{Type: shared.PointerTo("text"), Text: shared.PointerTo("Generating code...")}},
		},
		Timestamp: time.Now(),
	}
	select {
	case updates <- a2a.A2AYieldUpdate{Status: &workingStatus}:
	case <-ctx.Done():
		return ctx.Err() // Task canceled or context closed
	}

	// 2. Simulate code generation (replace with actual LLM call in real implementation)
	// Extract the user's request from the task history or initial message (simplified here)
	// For this example, we'll just generate fixed dummy files.
	generatedFiles := map[string]string{
		"main.go": `package main
import "fmt"
// main prints hello world.
func main() {
	fmt.Println("Hello, A2A World!")
}`,
		"utils/helper.go": `package utils
// Add performs addition.
func Add(a, b int) int {
	return a + b
}`,
		"README.md": `# My Generated Project
This project was generated by the Go A2A Coder Agent.`,
	}

	filenames := []string{"main.go", "utils/helper.go", "README.md"} // Ensure consistent order

	// 3. Stream artifact updates for each generated file
	for i, filename := range filenames {
		content := generatedFiles[filename]
		fileContentBase64 := base64.StdEncoding.EncodeToString([]byte(content))
		mimeType := "text/plain" // Default, could be more specific
		if strings.HasSuffix(filename, ".go") {
			mimeType = "text/x-golang"
		} else if strings.HasSuffix(filename, ".md") {
			mimeType = "text/markdown"
		}

		artifact := a2aSchema.Artifact{
			Name: &filename,
			Parts: []a2aSchema.Part{{Type: shared.PointerTo("file"), File: &a2aSchema.FileContent{
				Name:     &filename,
				MimeType: &mimeType,
				Bytes:    &fileContentBase64,
			}}},
			Index:     i,                      // Use index for ordering
			LastChunk: shared.PointerTo(true), // Mark each file artifact as complete
		}

		select {
		case updates <- a2a.A2AYieldUpdate{Artifact: &artifact}:
			// Simulate some delay between sending files
			select {
			case <-time.After(500 * time.Millisecond):
			case <-ctx.Done():
				return ctx.Err()
			}
		case <-ctx.Done():
			return ctx.Err()
		}
	}

	// 4. Send final "completed" status
	summary := fmt.Sprintf("Generated %d files: %s", len(filenames), strings.Join(filenames, ", "))
	completedStatus := a2aSchema.TaskStatus{
		State: a2aSchema.TaskStateCompleted,
		Message: &a2aSchema.Message{
			Role:  "agent",
			Parts: []a2aSchema.Part{{Type: shared.PointerTo("text"), Text: shared.PointerTo(summary)}},
		},
		Timestamp: time.Now(),
	}
	select {
	case updates <- a2a.A2AYieldUpdate{Status: &completedStatus}:
	case <-ctx.Done():
		// If context is cancelled before sending final status, the error is returned
		return ctx.Err()
	}

	return nil // Handler completed successfully
}

func main() {
	// --- Basic Setup ---
	logerConfig := zap.NewProductionConfig()
	logerConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	logger, _ := logerConfig.Build()
	defer logger.Sync()

	listenAddr := flag.String("listen", ":41241", "Address and port to listen on")
	agentURL := flag.String("agent-url", "http://localhost:41241/a2a", "Public URL for the agent endpoint")
	flag.Parse()

	// Update Agent Card URL
	coderAgentCard.URL = *agentURL

	// Use internal config for simplicity, A2A example doesn't need complex user/backend management
	cfg := config.NewInternalConfig()
	cfg.AuthorizationTypeValue = config.NotAuthorizedEverywhere // Allow all requests for this example

	// --- A2A Setup ---
	taskStore := a2a.NewInMemoryTaskStore()
	a2aCap := a2a.NewA2ACapability(logger, nil, taskStore, coderAgentHandler) // Manager is nil for now

	// --- Server Setup ---
	// Create MCP Manager (even if not strictly used by A2A Cap, transport might expect it)
	sessionManager, err := mcp.NewManager(logger, cfg)
	if err != nil {
		logger.Fatal("Failed to create session manager", zap.Error(err))
	}
	// IMPORTANT: Provide the manager to the A2A capability *after* both are created.
	// This is needed for A2A capability to send SSE events via the session manager.
	a2aCap.SetManager(sessionManager) // Need to add SetManager method to A2ACapability

	// Register A2A Capability with the input processor
	sessionManager.AddCapability(a2aCap) // Assuming AddCapability registers handlers

	// Create Transport, passing the A2A capability
	httpTransport, err := transport.New(sessionManager, logger, cfg)
	if err != nil {
		logger.Fatal("Failed to create transport", zap.Error(err))
	}

	mux := http.NewServeMux()

	// Register A2A handler at /a2a
	mux.HandleFunc(transport.A2A_PATH, httpTransport.HandleA2A()) // Use constant for path
	logger.Info("Registered A2A handler", zap.String("path", transport.A2A_PATH))

	// Register Agent Card handler
	mux.HandleFunc("/.well-known/agent.json", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Access-Control-Allow-Origin", "*") // Allow CORS for discovery
		json.NewEncoder(w).Encode(coderAgentCard)
	})
	logger.Info("Registered Agent Card handler", zap.String("path", "/.well-known/agent.json"))

	// --- Start Server ---
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	logger.Info("Starting A2A Coder Agent Server", zap.String("address", *listenAddr), zap.String("agentURL", *agentURL))

	serverInstance, listenerErrChan, startErr := transport.StartHTTPServer(ctx, logger, cfg, mux, *listenAddr)
	if startErr != nil {
		logger.Fatal("Failed to start HTTP server", zap.Error(startErr))
	}

	// --- Graceful Shutdown ---
	signalCh := make(chan os.Signal, 1)
	signal.Notify(signalCh, syscall.SIGINT, syscall.SIGTERM)

	select {
	case sig := <-signalCh:
		logger.Info("Received shutdown signal", zap.String("signal", sig.String()))
		cancel() // Trigger context cancellation
	case err := <-listenerErrChan:
		if err != nil {
			logger.Error("HTTP listener error", zap.Error(err))
		}
		cancel() // Trigger context cancellation if listener fails
	case <-ctx.Done(): // Handle potential external cancellation
		logger.Info("Server context cancelled externally")
	}

	logger.Info("Shutting down server...")
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer shutdownCancel()
	transport.ShutdownHTTPServer(shutdownCtx, logger, serverInstance)
	logger.Info("Server stopped")
}
